<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://purplest.github.io/newblog/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/newblog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/newblog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/newblog/">Home</a>
        
          <a class="main-nav-link" href="/newblog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://purplest.github.io/newblog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Contravariance &amp; Covariance In Java Generics" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/09/20/Contravariance & Covariance In Java Generics/" class="article-date">
  <time datetime="2016-09-19T16:00:00.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/architecture/">architecture</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/09/20/Contravariance & Covariance In Java Generics/">Contravariance &amp; Covariance in Java Generics</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-Generics"><a href="#Java-Generics" class="headerlink" title="Java Generics"></a>Java Generics</h1><p>Java 泛型相较于C++的实现，有联系，也有区别。下面通过一个栗子来了解。</p>
<h3 id="一个Arrays引发的Exception"><a href="#一个Arrays引发的Exception" class="headerlink" title="一个Arrays引发的Exception"></a>一个Arrays引发的Exception</h3><p>首先，我们定义以下两个array。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer[] arrInt = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</div><div class="line">Number[] arrNum = arrInt;</div></pre></td></tr></table></figure>
<p>很显然，把arrNum指向arrInt是没有任何问题的。但是如果像下面这样改变其中的某个值呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrNum[<span class="number">1</span>]=<span class="number">1.1</span>;</div></pre></td></tr></table></figure>
<p>对于编译器来说，这样是完全没有问题的，因为Double是Number的子类。但是如果运行的话，会抛出<code>java.lang.ArrayStoreException</code>，因为arrNum本质还是一个Integer array，把一个Double放进一个Integer里显然是不可能的。</p>
<p>回到问题的本质，这样相当于绕过了编译器，但是对runtime环境来说，arrNum指向的对象在JVM中其实还是个Integer[]的实例。</p>
<p>因此，我们也把arrays称作<code>reifiable type</code>。</p>
<h3 id="Java-Generics-1"><a href="#Java-Generics-1" class="headerlink" title="Java Generics"></a>Java Generics</h3><p>在JVM中，并没有泛型这个东西，而JDK 1.5之后其实也是通过type erasure，利用 compiler添加的bridge方法来实现泛型的。</p>
<p>因为在JVM里并不存在泛型，所以没办法拿到type infomation，所以也没办法避免可能的heap pollution。比如下面的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">integerList.add(<span class="number">2</span>);</div><div class="line">integerList.add(<span class="number">3</span>);</div><div class="line">integerList.add(<span class="number">5</span>);</div><div class="line"></div><div class="line">List&lt;Number&gt; numberList = integerList;<span class="comment">//compiler error</span></div></pre></td></tr></table></figure>
<p>很显然，把List<number>指向List<integer>，会导致compile error，如果编译器不阻止这种转换，就会导致下面的heap pollution。</integer></number></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numberList.add(<span class="number">3.14</span>);<span class="comment">//heap pollution</span></div></pre></td></tr></table></figure>
<p>因此，我们也把泛型的这种情况称作<code>non-reifiable type</code>。</p>
<h3 id="In-polymorphism"><a href="#In-polymorphism" class="headerlink" title="In polymorphism"></a>In polymorphism</h3><p>下面再看个多态的栗子，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(Number[] numbers)</span> </span>&#123;</div><div class="line">	<span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (Number number : numbers) &#123;</div><div class="line">		sum += number.longValue();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer[] integers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</div><div class="line">Long[] longs = &#123;<span class="number">2l</span>, <span class="number">3l</span>, <span class="number">5l</span>, <span class="number">7l</span>, <span class="number">11l</span>&#125;;</div><div class="line">Double[] doubles = &#123;<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">11.0</span>&#125;;</div><div class="line"></div><div class="line">System.out.println(sum(integers));</div><div class="line">System.out.println(sum(longs));</div><div class="line">System.out.println(sum(doubles));</div></pre></td></tr></table></figure>
<p>显然，这样调用是没问题的，但是直接传一个arrays并不符合封装性，可能导致其他的问题。那我们换做泛型来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">(List&lt;Number&gt; numbers)</span> </span>&#123;</div><div class="line">	<span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span> (Number number : numbers) &#123;</div><div class="line">		sum += number.longValue();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了上面的经验，想当然的试着这么调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; integers = Lists.newArrayList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>);</div><div class="line">List&lt;Long&gt; longs = Lists.newArrayList(<span class="number">2l</span>, <span class="number">3l</span>, <span class="number">5l</span>, <span class="number">7l</span>, <span class="number">11l</span>);</div><div class="line">List&lt;Double&gt; doubles = Lists.newArrayList(<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">11.0</span>);</div><div class="line"></div><div class="line">System.out.println(sum(integers));</div><div class="line">System.out.println(sum(longs));</div><div class="line">System.out.println(sum(doubles));</div></pre></td></tr></table></figure>
<p>然而事实是残酷的，编译器拒绝了我并抛了一个Error。为了一探究竟，我们需要了解Java Generics中两个非常有用的特性：covariance和contravariance。</p>
<h3 id="Covariance"><a href="#Covariance" class="headerlink" title="Covariance"></a>Covariance</h3><p>在covariance中，我们可以read泛型中的某个item，但是禁止write。比如有以下的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;? extends Number&gt; integers = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">List&lt;? extends Number&gt; longs = <span class="keyword">new</span> ArrayList&lt;Long&gt;();</div><div class="line">List&lt;? extends Number&gt; doubles = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</div></pre></td></tr></table></figure>
<p>那么我们可以随意的read某个item：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Number numberI = integers.get(<span class="number">1</span>)</div><div class="line">Number numberL = longs.get(<span class="number">1</span>)</div><div class="line">Number numberD = doubles.get(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>因为在这个泛型中，限制了所有的元素一定为Number的子类，所以我们肯定可以upcaset to Number。</p>
<p>但是，在covariance中却无法write：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">numberI.add(<span class="number">7</span>); <span class="comment">//compiler error</span></div></pre></td></tr></table></figure>
<p>因为numberI限定了所有元素是Number的子类，但却不知道到底是哪个子类（也许是个List<double>呢？），因为编译器无法保证它的真正的类型是什么。所以，可以达到只读的特性。</double></p>
<h3 id="Contravariance"><a href="#Contravariance" class="headerlink" title="Contravariance"></a>Contravariance</h3><p>同样的，covariance反过来就是contravariance。我们可以在泛型中write，但是禁止write。栗子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">list.add(<span class="keyword">new</span> BigInteger(<span class="string">"1024"</span>));</div><div class="line">list.add(<span class="string">"65535"</span>);</div><div class="line"></div><div class="line">List&lt;? <span class="keyword">super</span> Number&gt; numbers = list;</div><div class="line">numbers.add(<span class="number">64</span>);</div></pre></td></tr></table></figure>
<p>因为Object一定是Number的父类，而Number是Interger的父类，所以这个add是合法的。</p>
<p>但是，在contravariance中却无法read：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Number number = numbers.get(<span class="number">0</span>); <span class="comment">//compiler error</span></div></pre></td></tr></table></figure>
<p>因为编译器只知道下限，却无法知道具体是哪个父类。如果编译器允许这种add，则可能导致运行时抛出<code>java.lang.ClassCastException</code>。</p>
<h3 id="Best-practice"><a href="#Best-practice" class="headerlink" title="Best practice"></a>Best practice</h3><p>在弄清楚covariance和contravariance之后，我们就有办法用好这两个特性了，有个总结是：PECS，即：”Producer extends, Comsumer super”。</p>
<p>对于需要read的泛型，可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">(List&lt;? extends Number&gt; items)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (Number item : items) &#123;</div><div class="line">		<span class="keyword">do</span> (item);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于需要write的泛型，可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(List&lt;? <span class="keyword">super</span> Number&gt; items)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (Number obj : list) &#123;</div><div class="line">		items.add(obj);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上所有内容可以参考<a href="http://stackoverflow.com/questions/1368166/what-is-a-difference-between-super-e-and-extends-e" target="_blank" rel="external">stackoverflow</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/09/20/Contravariance & Covariance In Java Generics/" data-id="cj0waogan00015wsk8bz05oti" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Reference type of volatile" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/08/15/Reference type of volatile/" class="article-date">
  <time datetime="2016-08-14T16:00:00.000Z" itemprop="datePublished">2016-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/architecture/">architecture</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/08/15/Reference type of volatile/">Reference type of volatile</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>众所周知，在Java中，由JMM保证了volatile的顺序性以及可见性，并且能看到很多介绍volatile的文章，但是大家在介绍volatile的时候，似乎都在着重说明volatile的语义，以及JVM如何在跨平台的时候插入内存屏障来保证volatile的特性的，而在举例子的时候，似乎都是用primitive type作为例子的，比如，boolean作为开关，int作为计数器 or version ID。</p>
<p>但是一直有个疑问，对于reference type，JVM到底是如何保证volatile的语义的呢？会不会像final一样，仅仅只是修饰这个reference呢？带着这个疑问，咱们尝试通过汇编代码来一探究竟。</p>
<h3 id="0-准备工具"><a href="#0-准备工具" class="headerlink" title="0.准备工具"></a>0.准备工具</h3><p>显然，普通方法是没办法查看到对应的汇编代码的。通过javac xxx只能看到对应的bytecode，对底层的内存屏障之类的东西，其实还是透明的。so，咱们需要引入一个小工具，它叫hsdis。</p>
<p>关于这个小工具，有很多办法可以获取，<a href="https://kenai.com/projects/base-hsdis/downloads" target="_blank" rel="external">Kenai官方</a>提供了bsd、linux以及solaris所对应的.so，选择对应的CPU架构即可（i386 or amd64）。</p>
<p>当然，这个时候肯定有人跳出来说，“喂，就这么无视我们windows么？”nonono，我才不会说我也用的是windows呢~对应的方法，无非也就是：</p>
<ul>
<li>[ ] <a href="http://dropzone.nfshost.com/hsdis.htm" target="_blank" rel="external">自己编译，丰衣足食</a>。</li>
<li>[x] <a href="http://vorboss.dl.sourceforge.net/project/fcml/fcml-1.1.1/hsdis-1.1.1-win32-amd64.zip" target="_blank" rel="external">吃拿卡要~</a></li>
</ul>
<p>作为一个懒到了无药可救的人来说，肯定是选择第二个啦~</p>
<p>偷偷的说一句，其实只是参考了<a href="http://stackoverflow.com/questions/1503479/how-to-see-jit-compiled-code-in-jvm" target="_blank" rel="external">这个答案</a>的啦~</p>
<p>当然，废话一句，下载后讲dll放进<code>%JAVA_HOME%\jre\bin\server</code>就OK了</p>
<h3 id="1-热身"><a href="#1-热身" class="headerlink" title="1.热身"></a>1.热身</h3><p>下面是见证奇迹的时刻。</p>
<p>首先，我们先来一段简单的代码热热身，先看看primitive type生成的汇编指令是啥样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        i = <span class="number">5</span>;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Main main = <span class="keyword">new</span> Main();</div><div class="line">        System.out.println(main.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为生成的汇编代码实在太多了，因此我们需要限制某个点，就取get方法，并且重定向一下。</p>
<p><code>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp -XX:CompileCommand=dontinline,*Main.get -XX:CompileCommand=compileonly,*Main.get Main &gt; main</code></p>
<p>因为汇编代码实在太多，因此只取部分来说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">0x0000000002a5fc5f: mov     rax,170802d0h     ;   &#123;metadata(&#123;method&#125; &#123;0x00000000170802d8&#125; &apos;get&apos; &apos;()I&apos; in &apos;Main&apos;)&#125;</div><div class="line">0x0000000002a5fc69: and     esi,0h</div><div class="line">0x0000000002a5fc6c: cmp     esi,0h</div><div class="line">0x0000000002a5fc6f: je      2a5fc91h          ;*aload_0</div><div class="line">                                              ; - Main::get@0 (line 6)</div><div class="line"></div><div class="line">0x0000000002a5fc75: mov     eax,5h</div><div class="line">0x0000000002a5fc7a: mov     dword ptr [rdx+0ch],eax</div><div class="line">0x0000000002a5fc7d: lock add dword ptr [rsp],0h  ;*putfield i</div><div class="line">                                              ; - Main::get@2 (line 6)</div><div class="line"></div><div class="line">0x0000000002a5fc82: mov     eax,dword ptr [rdx+0ch]  ;*getfield i</div><div class="line">                                              ; - Main::get@6 (line 7)</div><div class="line"></div><div class="line">0x0000000002a5fc85: add     rsp,30h</div><div class="line">0x0000000002a5fc89: pop     rbp</div><div class="line">0x0000000002a5fc8a: test    dword ptr [1e0100h],eax  ;   &#123;poll_return&#125;</div><div class="line">0x0000000002a5fc90: ret</div></pre></td></tr></table></figure>
<p>恩，非常棒的是，列出了调用的方法名，返回值，以及第几行。</p>
<p>我们可以看到，因为在intel的X86架构下，只对<code>StoreLoad</code>操作需要添加内存屏障（具体细节请参考<a href="http://g.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="external">JSR-133</a>），而从生成的汇编指令中也可以看出，是通过<code>lock add xxx</code>操作来达到目的。</p>
<h3 id="2-正餐"><a href="#2-正餐" class="headerlink" title="2.正餐"></a>2.正餐</h3><p>那试完了primitive type，就该来看看reference type了。</p>
<p>首先先看java源码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> num;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">volatile</span> Inner inner;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.inner = <span class="keyword">new</span> Inner();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        inner = <span class="keyword">new</span> Inner();</div><div class="line">        inner.num = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> inner;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Main main = <span class="keyword">new</span> Main();</div><div class="line">        System.out.println(main.get());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于inner的new和inner.num的复制操作，会是哪个需要加入内存屏障呢？根据我们的经验，这个volatile应该是用来修饰inner的，那么我们生成汇编指令来看看呗。</p>
<p>还是熟悉的味道，还是原来的代码来生成汇编指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">0x0000000002a40a87: call    2985ee0h          ; OopMap&#123;[56]=Oop [48]=Oop off=204&#125;</div><div class="line">                                              ;*invokespecial &lt;init&gt;</div><div class="line">                                              ; - Main::get@7 (line 14)</div><div class="line">                                              ;   &#123;optimized virtual_call&#125;</div><div class="line">0x0000000002a40a8c: mov     rax,qword ptr [rsp+30h]</div><div class="line">0x0000000002a40a91: mov     rdx,qword ptr [rsp+38h]</div><div class="line">0x0000000002a40a96: mov     r10,rax</div><div class="line">0x0000000002a40a99: mov     dword ptr [rdx+0ch],r10d</div><div class="line">0x0000000002a40a9d: mov     rax,rdx</div><div class="line">0x0000000002a40aa0: shr     rax,9h</div><div class="line">0x0000000002a40aa4: mov     rsi,118f5000h</div><div class="line">0x0000000002a40aae: mov     byte ptr [rax+rsi],0h</div><div class="line">0x0000000002a40ab2: lock add dword ptr [rsp],0h  ;*putfield inner</div><div class="line">                                              ; - Main::get@10 (line 14)</div><div class="line"></div><div class="line">0x0000000002a40ab7: mov     eax,dword ptr [rdx+0ch]  ;*getfield inner</div><div class="line">                                              ; - Main::get@14 (line 15)</div><div class="line"></div><div class="line">0x0000000002a40aba: mov     dword ptr [rax+0ch],0h  ;*putfield num</div><div class="line">                                              ; - Main::get@18 (line 15)</div><div class="line">                                              ; implicit exception: dispatches to 0x0000000002a40af4</div><div class="line">0x0000000002a40ac1: mov     eax,dword ptr [rdx+0ch]  ;*getfield inner</div><div class="line">                                              ; - Main::get@22 (line 16)</div><div class="line"></div><div class="line">0x0000000002a40ac4: add     rsp,50h</div><div class="line">0x0000000002a40ac8: pop     rbp</div><div class="line">0x0000000002a40ac9: test    dword ptr [260100h],eax  ;   &#123;poll_return&#125;</div><div class="line">0x0000000002a40acf: ret</div></pre></td></tr></table></figure>
<p>汇编很长，照理只截取重点。</p>
<p>可以从汇编指令中看到，首先有个call，这个call的作用是调用<code>*invokespecial &lt;init&gt;</code>来初始化inner的（1.7新加入的指令），初始化完后JVM直接在第14行后用<code>lock add xxx</code>来做了同步，而下面的第15行对inner.num的写入操作被JVM红果果的忽视了。</p>
<p>看来已经通过汇编源码验证了咱们的猜想，已经是时候下结论了，即volatile只是保证它修饰的那个参数的正确同步，对于reference type来说，只能保证对引用的正确同步。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/08/15/Reference type of volatile/" data-id="cj0waogb400095wskep504gjv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MongoDB Tutorial ①安装及基本概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/05/24/MongoDB Tutorial ①安装及基本概念/" class="article-date">
  <time datetime="2016-05-23T16:00:00.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/MongoDB/">MongoDB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/05/24/MongoDB Tutorial ①安装及基本概念/">MongoDB Tutorial ①安装及基本概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安装及基本概念"><a href="#安装及基本概念" class="headerlink" title="安装及基本概念"></a>安装及基本概念</h1><hr>
<h3 id="1-选择适合操作系统的版本"><a href="#1-选择适合操作系统的版本" class="headerlink" title="1.选择适合操作系统的版本"></a>1.选择适合操作系统的版本</h3><p>MongoDB的安装非常简单，由于我是在服务器上搭建的集群，所以集群搭建在Linux上，环境是CentOS 6.2。其他安装方法可以<a href="https://docs.mongodb.com/manual/installation/" target="_blank" rel="external">参考官方Tutorial</a>。</p>
<hr>
<h3 id="2-Package选择"><a href="#2-Package选择" class="headerlink" title="2.Package选择"></a>2.Package选择</h3><p>因为32bit系统有2G文件大小限制，官方也不推荐使用，所以直接滤过32bit。</p>
<p>目前MongoDB最新版本是3.2.6，据官方文档，该版本的性能有所提高，故选择该版本做测试。</p>
<p>官方提供的Package一共有5个：</p>
<table>
<thead>
<tr>
<th>mongodb-org</th>
<th>A metapackage that will automatically install the four component packages listed below.</th>
</tr>
</thead>
<tbody>
<tr>
<td>mongodb-org-server</td>
<td>Contains the mongod daemon and associated configuration and init scripts.</td>
</tr>
<tr>
<td>mongodb-org-mongos</td>
<td>Contains the mongos daemon.</td>
</tr>
<tr>
<td>mongodb-org-shell</td>
<td>Contains the mongo shell.</td>
</tr>
<tr>
<td>mongodb-org-tools</td>
<td>Contains the following MongoDB tools: mongoimport bsondump, mongodump, mongoexport, mongofiles, mongooplog, mongoperf, mongorestore, mongostat, and mongotop.</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="3-Install-yum"><a href="#3-Install-yum" class="headerlink" title="3.Install (yum)"></a>3.Install (yum)</h3><h6 id="①-创建-repo"><a href="#①-创建-repo" class="headerlink" title="① 创建 .repo"></a>① 创建 .repo</h6><p>创建yum的resp文件： /etc/yum.repos.d/mongodb-org-3.2.repo<br>并写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[mongodb-org-3.2]</div><div class="line">name=MongoDB Repository</div><div class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/</div><div class="line">gpgcheck=1</div><div class="line">enabled=1</div><div class="line">gpgkey=https://www.mongodb.org/static/pgp/server-3.2.asc</div></pre></td></tr></table></figure>
<h6 id="②-安装"><a href="#②-安装" class="headerlink" title="② 安装"></a>② 安装</h6><p>如果直接安装全部package，直接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install -y mongodb-org</div></pre></td></tr></table></figure>
<p>或者指定package和version：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install -y mongodb-org-3.2.6 mongodb-org-server-3.2.6 mongodb-org-shell-3.2.6 mongodb-org-mongos-3.2.6 mongodb-org-tools-3.2.6</div></pre></td></tr></table></figure>
<h6 id="③-关闭SELinux的权限限制（如果有）"><a href="#③-关闭SELinux的权限限制（如果有）" class="headerlink" title="③ 关闭SELinux的权限限制（如果有）"></a>③ 关闭SELinux的权限限制（如果有）</h6><p>定位到/etc/selinux/config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELINUX=disabled</div></pre></td></tr></table></figure>
<hr>
<h3 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h3><p>至此，已经安装完毕，即可启动MongoDB了。官方文档使用service的方式来启动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo service mongod start</div></pre></td></tr></table></figure>
<p>但是由于在测试环境，很多参数需要不断添加，故在测试中没使用该方式。习惯于创建一个owner是mongod的目录，并手动指定参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[xxx@l-xxx.wap.beta.cn0 ~]$ cd /home/q/mongo</div><div class="line">[xxx@l-xxx.wap.beta.cn0 /home/q/mongo]$ ll</div><div class="line">total 16</div><div class="line">drwxr-xr-x 2 mongod mongod 4096 May 23 20:57 log</div><div class="line">drwxr-xr-x 4 mongod mongod 4096 May 24 19:51 s1</div><div class="line">drwxr-xr-x 2 mongod mongod 4096 May 23 18:13 s2</div><div class="line">drwxr-xr-x 2 mongod mongod 4096 May 23 18:13 s3</div><div class="line">[xxx@l-xxx.wap.beta.cn0 /home/q/mongo]$ sudo -u mongod mongod --dbpath ./s1/ --port 29001 --fork --logpath ./log/s1.log --logappend</div><div class="line">about to fork child process, waiting until server is ready for connections.</div><div class="line">forked process: 7211</div><div class="line">child process started successfully, parent exiting</div><div class="line">[xxx@l-xxx.wap.beta.cn0 /home/q/mongo]$  mongo --port 29001</div><div class="line">MongoDB shell version: 3.2.6</div><div class="line">connecting to: 127.0.0.1:29001/test</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>MongoDB和关系型数据库，如MySQL很类似也有数据库的概念。默认登录MongoDB以后，使用的是test库，我们可以使用<code>db</code>命令来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db</div><div class="line">test</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>当然也可以用<code>show dbs</code>命令查看当前所有的数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; show dbs</div><div class="line">local    3.845GB</div><div class="line">record  33.071GB</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>如果要切换数据库，用<code>use &lt;db-name&gt;</code>来切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; use record</div><div class="line">switched to db record</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>在db下，分别有很多集合(collections)，等同于MySQL的table。可以用<code>show collections</code>命令来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; show collections</div><div class="line">test</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<hr>
<h3 id="5-CRUD"><a href="#5-CRUD" class="headerlink" title="5.CRUD"></a>5.CRUD</h3><h6 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h6><p>在MongoDB中，通常使用<code>db.collection.insert()</code>来插入数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.records.insert(</div><div class="line">    &#123;</div><div class="line">        <span class="attr">foo</span>: <span class="string">"asdf"</span>,</div><div class="line">        <span class="attr">bar</span>: <span class="string">"qwerty"</span></div><div class="line">    &#125;</div><div class="line">)</div><div class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>WriteResult里会对当前的操作进行统计，上面的结果表示成功插入1条数据。</p>
<p>然后可以直接用<code>db.collection.find()</code>来查看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.test.find()</div><div class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5744517551076b823ea49fd2"</span>), <span class="string">"foo"</span> : <span class="string">"asdf"</span>, <span class="string">"bar"</span> : <span class="string">"qwerty"</span> &#125;</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>可以加.pretty()来格式化json：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.test.find().pretty()</div><div class="line">&#123;</div><div class="line">	<span class="string">"_id"</span> : ObjectId(<span class="string">"5744517551076b823ea49fd2"</span>),</div><div class="line">	<span class="string">"foo"</span> : <span class="string">"asdf"</span>,</div><div class="line">	<span class="string">"bar"</span> : <span class="string">"qwerty"</span></div><div class="line">&#125;</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>更多insert操作请参考<a href="https://docs.mongodb.com/manual/tutorial/insert-documents/" target="_blank" rel="external">Insert Documents</a></p>
<h6 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h6><p>我们可以指定查询条件，进行精确查找、或者匹配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.test.find(&#123;<span class="attr">foo</span>:<span class="string">"asdf"</span>&#125;).pretty()</div><div class="line">&#123;</div><div class="line">	<span class="string">"_id"</span> : ObjectId(<span class="string">"5744517551076b823ea49fd2"</span>),</div><div class="line">	<span class="string">"foo"</span> : <span class="string">"asdf"</span>,</div><div class="line">	<span class="string">"bar"</span> : <span class="string">"qwerty"</span></div><div class="line">&#125;</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>当然结果和上面一样。更多请参考<a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank" rel="external">Query Documents</a></p>
<h6 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h6><p>修改通常使用<code>db.collection.update()</code>来做修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.test.update(</div><div class="line">    &#123; <span class="attr">foo</span>: <span class="string">"asdf"</span> &#125;,</div><div class="line">    &#123;</div><div class="line">        <span class="attr">$set</span>: &#123;</div><div class="line">            <span class="attr">bar</span>: <span class="string">"aaaa"</span>,</div><div class="line">            <span class="attr">price</span>: <span class="number">15</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">)</div><div class="line">WriteResult(&#123; <span class="string">"nMatched"</span> : <span class="number">1</span>, <span class="string">"nUpserted"</span> : <span class="number">0</span>, <span class="string">"nModified"</span> : <span class="number">1</span> &#125;)</div><div class="line">MongoDB Enterprise &gt; db.test.find().pretty()</div><div class="line">&#123;</div><div class="line">	<span class="string">"_id"</span> : ObjectId(<span class="string">"5744517551076b823ea49fd2"</span>),</div><div class="line">	<span class="string">"foo"</span> : <span class="string">"asdf"</span>,</div><div class="line">	<span class="string">"bar"</span> : <span class="string">"aaaa"</span>,</div><div class="line">	<span class="string">"price"</span> : <span class="number">15</span></div><div class="line">&#125;</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>更多请参考<a href="https://docs.mongodb.com/manual/tutorial/modify-documents/" target="_blank" rel="external">Update Documents</a></p>
<h6 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h6><p>删除通常用<code>db.collection.remove()</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MongoDB Enterprise &gt; db.test.remove(&#123;<span class="attr">foo</span>:<span class="string">"asdf"</span>&#125;)</div><div class="line">WriteResult(&#123; <span class="string">"nRemoved"</span> : <span class="number">1</span> &#125;)</div><div class="line">MongoDB Enterprise &gt;</div></pre></td></tr></table></figure>
<p>同样的，这里添加了删除条件，而”nRemoved”代表删除的数量。<br>更多参考<a href="https://docs.mongodb.com/manual/tutorial/remove-documents/" target="_blank" rel="external">Remove Documents</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/05/24/MongoDB Tutorial ①安装及基本概念/" data-id="cj0waogav00045wskwtau2g2b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Striped64" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/03/22/Striped64/" class="article-date">
  <time datetime="2016-03-21T16:00:00.000Z" itemprop="datePublished">2016-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/jdk-8/">jdk 8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/03/22/Striped64/">Striped64</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在上上篇blog中，介绍了LongAdder、LongAccumulator这两个类，但是还没说实现longAccumulate的Striped64类，这篇单独说之。</p>
<p>在LongAdder里边提到了Cell[]，其实关键在于维护这一系列并发的状态，而longAccumulate维护了这些状态。</p>
<p>简单来说，Cell[]一共有三种状态：</p>
<p>①Cell[]已经初始化；</p>
<p>②Cell[]未被初始化并且拿到了操作Cell[]的锁cellsBusy；</p>
<p>③Cell[]未被初始化并且没拿到cellsBusy锁；</p>
<ul>
<li>对于状态①，则在初始化的Cell[]里边进行操作即可；</li>
<li>对于状态②，既然拿到了锁cellsBusy，则初始化Cell[]并在初始化完后释放cellsBusy锁即可。</li>
<li>对于状态③，Cell[]未被初始化并且没拿到锁，说明Cell[]正在被初始化，也从侧面说明现在对base的竞争并不激烈，所以回退去使用base即可。</li>
</ul>
<p>下面详细对源码进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></div><div class="line">                                    <span class="keyword">boolean</span> wasUncontended) &#123;</div><div class="line">   <span class="keyword">int</span> h;</div><div class="line">   <span class="comment">//当前进程未被初始化（从1开始计数）</span></div><div class="line">   <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">//强制初始化</span></div><div class="line">      ThreadLocalRandom.current();</div><div class="line">      h = getProbe();</div><div class="line">      wasUncontended = <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;    <span class="comment">// True if last slot nonempty</span></div><div class="line">   <span class="keyword">for</span> (;;) &#123;</div><div class="line">      Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</div><div class="line">      <span class="comment">//状态①：Cell[]已初始化</span></div><div class="line">      <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</div><div class="line">         <span class="comment">//当前选择的slot是null的，则需要去初始化当前slot</span></div><div class="line">         <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//先去看能否拿到cellsBusy</span></div><div class="line">            <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</div><div class="line">               <span class="comment">//认为没有人去拿锁，先初始化Cell（即乐观锁）</span></div><div class="line">               Cell r = <span class="keyword">new</span> Cell(x);</div><div class="line">               <span class="comment">//初始化完后再去拿锁</span></div><div class="line">               <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</div><div class="line">                  <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></div><div class="line">                     Cell[] rs; <span class="keyword">int</span> m, j;</div><div class="line">                     <span class="comment">//拿到锁的情况下再确认当前slot是否为null</span></div><div class="line">                     <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                        (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">                        rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</div><div class="line">                        <span class="comment">//关联到当前位置的Cell</span></div><div class="line">                        rs[j] = r;</div><div class="line">                        created = <span class="keyword">true</span>;</div><div class="line">                     &#125;</div><div class="line">                  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                     <span class="comment">//释放锁</span></div><div class="line">                     cellsBusy = <span class="number">0</span>;</div><div class="line">                  &#125;</div><div class="line">                  <span class="keyword">if</span> (created)</div><div class="line">                     <span class="comment">//成功创建并关联到当前位置的Cell</span></div><div class="line">                     <span class="keyword">break</span>;</div><div class="line">                  <span class="comment">//否则slot不为null</span></div><div class="line">                  <span class="keyword">continue</span>;</div><div class="line">               &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//没能拿到cellsBusy锁，重新选择slot</span></div><div class="line">            collide = <span class="keyword">false</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//已经知道CAS会失败了，则重新选择slot后再继续</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)</div><div class="line">            wasUncontended = <span class="keyword">true</span>;</div><div class="line">          <span class="comment">//当前slot非null，则去试着CAS更新</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</div><div class="line">                                    fn.applyAsLong(v, x))))</div><div class="line">            <span class="comment">//更新成功</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">         <span class="comment">//超过CPU数限制or当前Cell[]已经扩容了</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</div><div class="line">            collide = <span class="keyword">false</span>;</div><div class="line">         <span class="comment">//如果没有竞争，则标记为存在竞争，并重新选择slot重试</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</div><div class="line">            collide = <span class="keyword">true</span>;</div><div class="line">         <span class="comment">//有竞争，并且拿到了cellsBusy锁，则进行扩容</span></div><div class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">               <span class="comment">// 再check一下Cell[]是否有过扩容</span></div><div class="line">               <span class="keyword">if</span> (cells == as) &#123;</div><div class="line">                  <span class="comment">//容量翻倍</span></div><div class="line">                  Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">                     rs[i] = as[i];</div><div class="line">                  cells = rs;</div><div class="line">               &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">               <span class="comment">//释放cellsBusy锁</span></div><div class="line">               cellsBusy = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            collide = <span class="keyword">false</span>;</div><div class="line">            <span class="comment">//在扩容后的Cell上重试</span></div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="comment">//rehash，选择其他slot</span></div><div class="line">         h = advanceProbe(h);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//状态②：Cell[]未被初始化，并且拿到了cellsBusy锁</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</div><div class="line">         <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</div><div class="line">         <span class="comment">//初始化Cell[]</span></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (cells == as) &#123;</div><div class="line">               Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</div><div class="line">               rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</div><div class="line">               cells = rs;</div><div class="line">               init = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">         &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放cellsBusy锁</span></div><div class="line">            cellsBusy = <span class="number">0</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (init)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//状态③：Cell[]正在被初始化，回退到CAS base</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</div><div class="line">                               fn.applyAsLong(v, x))))</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结:</p>
<p>Striped64实现了对Cell[]的维护以及选取slot更新，是LongAdder、LongAccumulator等类的基础。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/03/22/Striped64/" data-id="cj0waogb200075wskipwmfgdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-False sharing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/03/21/False sharing/" class="article-date">
  <time datetime="2016-03-20T16:00:00.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/architecture/">architecture</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/03/21/False sharing/">False sharing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在缓存系统（cache system）中，缓存行（cache lines）是最基本的存储单位，缓存行是2的整数次幂个连续的字节，一般是32-256个字节，最常见的一个缓存行是64个字节。CPU在读取数据的时候，是整个缓存行一起读取的，在多核处理器上，会发生竞争的问题，比如core A修改了变量X，core B修改了Y，而X，Y都在同一个缓存行上，因为数据一致性的问题，如果core A修改成功了，那么core B的缓存就失效了，数据必须从新去读取，反之亦然。如果发生的概率很高，必然会使cache失去了作用，导致效率降低。<br>（详细解读:<a href="http://ifeve.com/false-sharing/" target="_blank" rel="external">False sharing</a>）</p>
<p>在&lt;JDK 8之前的版本中，在面对false sharing的问题，通常解决办法是做填充，比如在1.7的ThreadLocalRandom中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandom</span> <span class="keyword">extends</span> <span class="title">Random</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * The random seed. We can't use super.seed.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> rnd;</div><div class="line"></div><div class="line">    <span class="comment">// Padding to help avoid memory contention among seed updates in</span></div><div class="line">    <span class="comment">// different TLRs in the common case that they are located near</span></div><div class="line">    <span class="comment">// each other.</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;</div></pre></td></tr></table></figure>
<p>对于HotSpot JVM的内存布局，可以参考<a href="http://www.infoq.com/cn/articles/jvm-hotspot" target="_blank" rel="external">HotSpot虚拟机对象探秘</a>，并不需要深入的去看JVM，只需要知道在任意字段间用7个long做cache lines的填充行即可。</p>
<p>但带来的问题是，每个CPU对cache lines的定义是不同的，这种手动添加padding的方式不一定适合当前的CPU，而且属于不可移植的代码，违背了java编译一次，到处运行的法则。</p>
<p>还好，在JDK8中，带来了一个新的annotation：<code>sun.misc.Contended</code>，让JVM在分配内存的时候自动根据当前CPU的特性添加padding，改动之后被挪到了Thread里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></div><div class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></div><div class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></div><div class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></div><div class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></div><div class="line"></div><div class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></div><div class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</div><div class="line"><span class="keyword">long</span> threadLocalRandomSeed;</div><div class="line"></div><div class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></div><div class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</div><div class="line"><span class="keyword">int</span> threadLocalRandomProbe;</div><div class="line"></div><div class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></div><div class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</div><div class="line"><span class="keyword">int</span> threadLocalRandomSecondarySeed;</div></pre></td></tr></table></figure>
<p><a href="http://mail.openjdk.java.net/pipermail/hotspot-dev/2012-November/007309.html" target="_blank" rel="external">JEP-142</a><br>相对于其他版本的解决方式，是不是JDK8实现的更优雅了呢？ :)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/03/21/False sharing/" data-id="cj0waogat00035wsku6o09qw2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-LongAdder&amp;LongAccumulator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2016/03/18/LongAdder&LongAccumulator/" class="article-date">
  <time datetime="2016-03-17T16:00:00.000Z" itemprop="datePublished">2016-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/jdk-8/">jdk 8</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2016/03/18/LongAdder&LongAccumulator/">LongAdder &amp; LongAccumulator</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在JDK1.8中，java.util.concurrent.atomic包下增加了几个类:LongAdder、LongAccumulator、DoubleAdder、DoubleAccumulator，都是原Atomic的改进版。</p>
<p>在原Atomic系列类中，通过CAS的方式来保证在并发环境下的原子性，相对于synchronized和lock的方式来说，在并发环境下已经高效了很多了。但是在高并发下，CAS造作的失败率也会增加很多，失败率的增加导致了更多线程的重试，不仅浪费资源，也导致Atomic的效率降低。</p>
<p>通过对Atomic在高并发下的分析可以发现，瓶颈在于对单一value进行CAS操作失败率的增高，那有没有办法降低对单一value的CAS操作呢？在新的LongAdder中（以LongAdder举例），在高并发环境下，将单一value的CAS压力分担到多个的value上去，从而降低了失败率，提高了性能。</p>
<h3 id="1-LongAdder"><a href="#1-LongAdder" class="headerlink" title="1.LongAdder"></a>1.LongAdder</h3><p>LongAdder继承自Striped64，而Striped64是实现在高并发下将压力分摊到不同value下的关键，并维护这些value。</p>
<p>LongAdder里的方法和Atomic里提供的方法很相似。</p>
<p>首先看add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</div><div class="line">	Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</div><div class="line">	<span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</div><div class="line">	    <span class="comment">//当对base的CAS操作失败后会进入</span></div><div class="line">		<span class="keyword">boolean</span> uncontended = </div><div class="line">		<span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</div><div class="line">			(a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</div><div class="line">			!(uncontended = a.cas(v = a.value, v + x)))</div><div class="line">			<span class="comment">//拿不到当前线程对应的cell或者对其CAS失败</span></div><div class="line">			longAccumulate(x, <span class="keyword">null</span>, uncontended);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在最开始，拿到了一个Cell的数组，这个Cell是Striped64的一个内部类，顾名思义，是Striped64用来分摊CAS压力的一个最小单元：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</div><div class="line">	<span class="keyword">volatile</span> <span class="keyword">long</span> value;</div><div class="line">	Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</div><div class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Unsafe mechanics</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">			Class&lt;?&gt; ak = Cell.class;</div><div class="line">			valueOffset = UNSAFE.objectFieldOffset</div><div class="line">				(ak.getDeclaredField(<span class="string">"value"</span>));</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sun.misc.Contended是对cache line进行填充，避免<code>false sharing</code>，JDK1.8中可以用该annotation而不是前后各加7个long，在这里不过多解释。<br>而Cell里的value，就是用来分担CAS更新的其中一个value，Cell里提供了对应的CAS操作。</p>
<p>我们回到add方法里。当并发很低的时候，基本没有CAS失败，所以通常情况下到第三行<code>!casBase(b = base, b + x)</code>中就进行了CAS操作；但是在并发量升高后，就会进入后续的判断,首先去拿Cell数组，并验证，根据当前线程的hash值，去拿Cell[]里的对应Cell，并对其的value进行CAS操作，如果Cell为null或者更新失败，就会进入Striped64的longAccumulate里进行操作。</p>
<p>longAccumulate过于复杂，暂时留在这里。</p>
<p>LongAdder还支持自增，自减操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</div><div class="line">    add(<span class="number">1L</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</div><div class="line">    add(-<span class="number">1L</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取值操作通过sum()来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</div><div class="line">    Cell[] as = cells; Cell a;</div><div class="line">    <span class="keyword">long</span> sum = base;</div><div class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                sum += a.value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即累加上所有value的值，即为最终的结果。<br>需要注意的是，同ConcurrentHashMap的size()一样，在取值的时候，并一定是当前的准确值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    Cell[] as = cells; Cell a;</div><div class="line">    base = <span class="number">0L</span>;</div><div class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</div><div class="line">                a.value = <span class="number">0L</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过reset操作，将所有value置为0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumThenReset</span><span class="params">()</span> </span>&#123;</div><div class="line">    Cell[] as = cells; Cell a;</div><div class="line">    <span class="keyword">long</span> sum = base;</div><div class="line">    base = <span class="number">0L</span>;</div><div class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>) &#123;</div><div class="line">                sum += a.value;</div><div class="line">                a.value = <span class="number">0L</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以及拿结果后reset</p>
<h3 id="2-LongAccumulator"><a href="#2-LongAccumulator" class="headerlink" title="2.LongAccumulator"></a>2.LongAccumulator</h3><p>LongAccumulator和LongAdder大同小异，只不过需要指定计算方法以及初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction,</span></span></div><div class="line">                       <span class="keyword">long</span> identity) &#123;</div><div class="line">    <span class="keyword">this</span>.function = accumulatorFunction;</div><div class="line">    base = <span class="keyword">this</span>.identity = identity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而这个accumulatorFunction即为对数值的计算方法，支持各种自定义运算。</p>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>通过对源码的分析，可以看出Doug Lea在对并发做处理的时候，优先考虑简单的更新办法，在当前没有更好的办法的情况下，再做出后续的处理，用空间去换时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2016/03/18/LongAdder&LongAccumulator/" data-id="cj0waogay00055wski77eoz5a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ByteCode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/newblog/2015/01/21/ByteCode/" class="article-date">
  <time datetime="2015-01-20T16:00:00.000Z" itemprop="datePublished">2015-01-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/newblog/categories/architecture/">architecture</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/newblog/2015/01/21/ByteCode/">ByteCode</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>之前版本的webentry需要判断每个.class文件（即对应的类上）是否被特定的annotation标记过（比如我们的@controller），若有，则用classloader加载；否则不管。</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="external">Java byteCode@wiki</a><br><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="external">Class file format@oracle</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ClassFile &#123;</div><div class="line">    u4             magic;</div><div class="line">    u2             minor_version;</div><div class="line">    u2             major_version;</div><div class="line">    u2             constant_pool_count;</div><div class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];</div><div class="line">    u2             access_flags;</div><div class="line">    u2             this_class;</div><div class="line">    u2             super_class;</div><div class="line">    u2             interfaces_count;</div><div class="line">    u2             interfaces[interfaces_count];</div><div class="line">    u2             fields_count;</div><div class="line">    field_info     fields[fields_count];</div><div class="line">    u2             methods_count;</div><div class="line">    method_info    methods[methods_count];</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="方案①"><a href="#方案①" class="headerlink" title="方案①"></a>方案①</h3><p>也就是之前采用的方案，用的是spring封装的byteCode reader。该reader是基于ASM的简化版，实现的功能算是比较完善，满足spring的需求。</p>
<p>优点：功能完善，且经过spring的使用，稳定性、兼容性能有保证。<br>缺点：相对于我们的需求，该reader提供了很多我们实际上用不到的东西，必然要承受的代价就是要慢很多，甚至有可能慢上半个数量级。</p>
<h3 id="方案②"><a href="#方案②" class="headerlink" title="方案②"></a>方案②</h3><p>该方法是spring封装的reader的改进版。因为我们的需求非常简单，只需要找到.class（即该类）是否被特定的annotation标记过，那该.class的很多东西都不需要处理，比如fields，methods。因为我们的annotation属于RuntimeVisibleAnnotations，所以只需要在attribute里面去遍历，看是否包含有该annotation即可。</p>
<p>细节：class文件是用流式处理的，严格按照class format格式化的，读取的时候需要顺序读取。比如我们RuntimeVisibleAnnotations，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RuntimeVisibleAnnotations_attribute &#123;</div><div class="line">    u2         attribute_name_index;</div><div class="line">    u4         attribute_length;</div><div class="line">    u2         num_annotations;</div><div class="line">    annotation annotations[num_annotations];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于每个annotation只能挨着去遍历，并且annotation里边的参数（key-value）也必须挨个读取。<br>我们的需求里面，不需要在这里处理参数，因此，不用真正的读取，只需要挨着跳过即可。</p>
<p>优点：简化了功能，只保留了我们需要用的功能，在本地测试，能减少50%左右的时间。<br>缺点：稳定性待验证。</p>
<h3 id="方案③"><a href="#方案③" class="headerlink" title="方案③"></a>方案③</h3><p>回顾我们的方案②，经过多次running，可以大概的把cost time分为如下图几部分：</p>
<p>$$\underbrace{\textrm{total time}}<em>\textrm{142 ms}  \Longrightarrow \begin{cases}<br> \underbrace{\textrm{part one}}</em>\textrm{86 ms}  \Longrightarrow<br>    \begin{cases}<br>        \underbrace{\textrm{read class(IO)}}<em>\textrm{29 ms} \<br>        \underbrace{\textrm{indexed constant pool}}</em>\textrm{3 ms} \<br>        alloc \ memory \ \&amp; \ other<br>    \end{cases}<br> \<br> \underbrace{\textrm{part two}}<em>\textrm{61 ms}  \Longrightarrow<br> \begin{cases}<br>        \underbrace{\textrm{skip method &amp; field}}</em>\textrm{2 ms} \<br>        \underbrace{\textrm{indexed constant pool}}_\textrm{56 ms} \<br>        other<br>    \end{cases}<br>\end{cases}$$</p>
<p>回到我们的需求，发现其实我们要的功能很简单，仅仅需要看他是否用了特定的annotation，而不关心更多东西，并且后面用classloader载入该.class。<br>因为在一个.class文件里，如果该class用到了一个类，那么，在它的constant pool里边一定会有这个类的引用。<br>所以，在indexed constant pool的时候，我们判断是否有该annotation的引用，如果有该annotation引用，那么很多情况下，这个.class是加上了这个annotation的（从class引用了该annotation，可以推出constant pool里边一定有该类的引用，是一个充分非必要条件，不能反推得出有该类的引用，则引用了该annotation）。</p>
<p>虽然该方案有缺陷，但是因为还有后边的反射做保证，所以，在兼顾性能的情况下，可以再省几近一半的时间，后面的测试也验证了该猜想。</p>
<p>大致的cost time分析：</p>
<p>$$\underbrace{\textrm{total time}}<em>\textrm{70 ms}  \Longrightarrow \begin{cases}<br>        \underbrace{\textrm{read class(IO)}}</em>\textrm{29 ms} \<br>        \underbrace{\textrm{indexed constant pool &amp; judge}}_\textrm{3 ms} \<br>        alloc \ memory \ \&amp; \ other<br>\end{cases}$$</p>
<p>当然，由于hotspot优化，这个时间不是特别的准，仅供参考。</p>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><p>三次分别运行的结果</p>
<p>|spring tool Time(方案①)|333ms|319ms|323ms<br>|normal Time(方案②)|142ms|128ms|124ms<br>|tiny Time(方案③)|70ms|63ms|60ms<br>|IO TIme|29ms|25ms|26ms<br>|normal percentage|42%|40%|38%<br>|tiny percentage|21%|19%|18%</p>
<h3 id="待继续深入优化的地方"><a href="#待继续深入优化的地方" class="headerlink" title="待继续深入优化的地方"></a>待继续深入优化的地方</h3><p>首先考虑到的是读写文件，也就是IO的优化。目前用的是FileInputStream，每读一个字符，就会有一个系统调用。并且，现在使用的是把一个.class全部读入内存，并未对4k之类的问题进行考虑。如果将来瓶颈还在这块，可以考虑继续在这里优化。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>将kylin的所有Service（共19个）copy了50次（共953个），放在了同一文件夹下进行的模拟测试。</p>
<p>hotdog的测试结果与kylin的测试结果接近。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://purplest.github.io/newblog/newblog/2015/01/21/ByteCode/" data-id="cj0waogai00005wskdtzpbb49" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorier</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/newblog/categories/MongoDB/">MongoDB</a></li><li class="category-list-item"><a class="category-list-link" href="/newblog/categories/architecture/">architecture</a></li><li class="category-list-item"><a class="category-list-link" href="/newblog/categories/jdk-8/">jdk 8</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/newblog/archives/2015/01/">January 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/newblog/2016/09/20/Contravariance & Covariance In Java Generics/">Contravariance &amp; Covariance in Java Generics</a>
          </li>
        
          <li>
            <a href="/newblog/2016/08/15/Reference type of volatile/">Reference type of volatile</a>
          </li>
        
          <li>
            <a href="/newblog/2016/05/24/MongoDB Tutorial ①安装及基本概念/">MongoDB Tutorial ①安装及基本概念</a>
          </li>
        
          <li>
            <a href="/newblog/2016/03/22/Striped64/">Striped64</a>
          </li>
        
          <li>
            <a href="/newblog/2016/03/21/False sharing/">False sharing</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/newblog/" class="mobile-nav-link">Home</a>
  
    <a href="/newblog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/newblog/fancybox/jquery.fancybox.css">
  <script src="/newblog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/newblog/js/script.js"></script>

  </div>
</body>
</html>